import { getAndAssertSingleCodePoint } from '../util/Char';
import type { CensorContext, TextCensorStrategy } from './TextCensor';

/**
 * A text censoring strategy that wraps the base strategy, adding the first
 * character of the match at the start.
 *
 * @example
 * ```typescript
 * const strategy = keepStartCensorStrategy(grawlixCensorStrategy());
 * const censor = new TextCensor().setStrategy(strategy);
 * // Before: 'fuck you'
 * // After: 'f$@* you'
 * ```
 *
 * @example
 * ```typescript
 * const strategy = keepStartCensorStrategy(keepEndCensorStrategy(asteriskCensorStrategy()));
 * const censor = new TextCensor().setStrategy(strategy);
 * // Before: 'fuck you'
 * // After: 'f**k you'
 * ```
 *
 * @param baseStrategy - Strategy to wrap. It will be used to generate the
 * start of the string.
 * @returns A [[TextCensorStrategy]] for use with the [[TextCensor]].
 */
export function keepStartCensorStrategy(baseStrategy: TextCensorStrategy): TextCensorStrategy {
	return (ctx: CensorContext) => {
		if (ctx.overlapsAtStart) return baseStrategy(ctx);
		const firstChar = String.fromCodePoint(ctx.input.codePointAt(ctx.startIndex)!);
		return firstChar + baseStrategy({ ...ctx, matchLength: ctx.matchLength - 1 });
	};
}

/**
 * A text censoring strategy that wraps the base strategy, adding the last
 * character of the match at the end.
 *
 * @example
 * ```typescript
 * const strategy = keepEndCensorStrategy(asteriskCensorStrategy());
 * const censor = new TextCensor().setStrategy(strategy);
 * // Before: 'fuck you'
 * // After: '***k you'
 * ```
 *
 * @param baseStrategy - Strategy to wrap. It will be used to generate the
 * start of the string.
 * @returns A [[TextCensorStrategy]] for use with the [[TextCensor]].
 */
export function keepEndCensorStrategy(baseStrategy: TextCensorStrategy): TextCensorStrategy {
	return (ctx: CensorContext) => {
		if (ctx.overlapsAtEnd) return baseStrategy(ctx);
		const lastChar = String.fromCodePoint(ctx.input.codePointAt(ctx.endIndex)!);
		return baseStrategy({ ...ctx, matchLength: ctx.matchLength - 1 }) + lastChar;
	};
}

/**
 * A text censoring strategy that generates strings made up of asterisks.
 *
 * @example
 * ```typescript
 * const strategy = asteriskCensorStrategy();
 * const censor = new TextCensor().setStrategy(strategy);
 * // Before: 'fuck you'
 * // After: '**** you'
 * ```
 *
 * @returns A [[TextCensorStrategy]] for use with the [[TextCensor]].
 */
export function asteriskCensorStrategy() {
	return fixedCharCensorStrategy('*');
}

/**
 * A text censoring strategy that generates
 * [grawlix](https://www.merriam-webster.com/words-at-play/grawlix-symbols-swearing-comic-strips).
 *
 * @example
 * ```typescript
 * const strategy = grawlixCensorStrategy();
 * const censor = new TextCensor().setStrategy(strategy);
 * // Before: 'fuck you'
 * // After: '%@&* you'
 *
 * @returns A [[TextCensorStrategy]] for use with the [[TextCensor]].
 */
export function grawlixCensorStrategy() {
	return randomCharFromSetCensorStrategy('%@$&*');
}

/**
 * A text censoring strategy that returns a fixed string.
 *
 * @example
 * ```typescript
 * const strategy = fixedPhraseCensorStrategy('');
 * const censor = new TextCensor().setStrategy(strategy);
 * // The replacement phrase '' effectively removes all matched regions
 * // from the string.
 * //
 * // Before: 'fuck you'
 * // After: ' you'
 * ```
 *
 * @example
 * ```typescript
 * const strategy = fixedPhraseCensorStrategy('fudge');
 * const censor = new TextCensor().setStrategy(strategy);
 * // Before: 'fuck you'
 * // After: 'fudge you'
 * ```
 *
 * @param phrase - Replacement phrase.
 * @returns A [[TextCensorStrategy]] for use with the [[TextCensor]].
 */
export function fixedPhraseCensorStrategy(phrase: string): TextCensorStrategy {
	return () => phrase;
}

/**
 * A text censoring strategy that generates replacements made up of a fixed
 * character. For example, a possible string generated by

 * @example
 * ```typescript
 * const strategy = fixedCharCensorStrategy('*');
 * const censor = new TextCensor().setStrategy(strategy);
 * // Before: 'fuck you'
 * // After: '**** you'.
 * ```
 *
 * @param char - String that represents the code point which should be used
 * when generating the replacement string. Must be exactly one code point
 * in length.
 * @returns A [[TextCensorStrategy]] for use with the [[TextCensor]].
 */
export function fixedCharCensorStrategy(char: string): TextCensorStrategy {
	getAndAssertSingleCodePoint(char);
	return (ctx: CensorContext) => char.repeat(ctx.matchLength);
}

/**
 * A text censoring strategy that generates replacements made up of characters
 * from the set of characters provided. For example, a possible string generated by
 *
 * @example
 * ```typescript
 * const strategy = randomCharFromSetCensorStrategy('$#!');
 * const censor = new TextCensor().setStrategy(strategy);
 * // Before: 'fuck you!'
 * // After: '!##$ you!'
 * ```
 *
 * @param charset - Set of characters from which the replacement string should
 * be constructed. Must not be empty.
 * @returns A [[TextCensorStrategy]] for use with the [[TextCensor]].
 */
export function randomCharFromSetCensorStrategy(charset: string): TextCensorStrategy {
	const chars = [...charset];
	if (chars.length === 0) throw new Error('The character set passed must not be empty.');
	return (ctx: CensorContext) => {
		let censored = '';
		for (let i = 0; i < ctx.matchLength; i++) censored += chars[Math.floor(Math.random() * chars.length)];
		return censored;
	};
}
